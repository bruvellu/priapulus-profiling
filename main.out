
real	101m15.583s
user	1074m55.042s
sys	27m48.293s

real	0m0.022s
user	0m0.001s
sys	0m0.003s

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> # Load read counts.
> Pc1_0d <- read.table("read_counts/Pc1_0d.counts", header=TRUE)
Error in read.table("read_counts/Pc1_0d.counts", header = TRUE) : 
  no lines available in input
Execution halted

real	0m10.840s
user	0m3.879s
sys	0m5.254s

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> # Load edgeR
> library(edgeR)
Loading required package: limma
> 
> # Keep only numeric columns.
> num_data <- data.matrix(merged_data[,2:12])
> 
> # Set NA values to 0:
> num_data[is.na(num_data)] <- 0
> 
> # Calculate normalization factor for each column.
> norm_factors <- calcNormFactors(num_data)
> 
> # Get sum of each column.
> lib.size <- colSums(num_data)
> 
> # Get effective size by multiplying size by normalization factor.
> lib.effective.size <- lib.size * norm_factors
> 
> # Get normalization multiplier to be applied into original counts.
> norm.multiplier <- 1000000 / lib.effective.size
> 
> # Create normalized matrix by multiplying normalization factor to counts.
> norm_data <- num_data * norm.multiplier
> 
> # Rename columns.
> colnames(norm_data) <- c("norm_count_Pc1_0d", "norm_count_Pc2_0d", "norm_count_Pc1_1d", "norm_count_Pc2_1d", "norm_count_Pc1_3d", "norm_count_Pc2_3d", "norm_count_Pc1_5d", "norm_count_Pc2_5d", "norm_count_Pc2_7d", "norm_count_Pc1_9d", "norm_count_Pc2_9d")
> 
> # Bind counts and normalize data.
> merged_data <- cbind(merged_data, norm_data)
> 
> # Remove NAs again.
> merged_data[is.na(merged_data)] <- 0
> 

real	0m37.865s
user	0m13.417s
sys	0m24.367s

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> # Build and save scatter plots for replicates.
> 
> pdf("plots/Pc1_0d__Pc2_0d.pdf")
> plot(merged_data$norm_count_Pc1_0d, merged_data$norm_count_Pc2_0d, log="xy", xlab="Pc1_0d normalized counts", ylab="Pc2_0d normalized counts", main="0d log distribution of normalized counts")
Warning messages:
1: In xy.coords(x, y, xlabel, ylabel, log) :
  24887 x values <= 0 omitted from logarithmic plot
2: In xy.coords(x, y, xlabel, ylabel, log) :
  30514 y values <= 0 omitted from logarithmic plot
> dev.off()
null device 
          1 
> 
> pdf("plots/Pc1_1d__Pc2_1d.pdf")
> plot(merged_data$norm_count_Pc1_1d, merged_data$norm_count_Pc2_1d, log="xy", xlab="Pc1_1d normalized counts", ylab="Pc2_1d normalized counts", main="1d log distribution of normalized counts")
Warning messages:
1: In xy.coords(x, y, xlabel, ylabel, log) :
  29473 x values <= 0 omitted from logarithmic plot
2: In xy.coords(x, y, xlabel, ylabel, log) :
  31463 y values <= 0 omitted from logarithmic plot
> dev.off()
null device 
          1 
> 
> pdf("plots/Pc1_3d__Pc2_3d.pdf")
> plot(merged_data$norm_count_Pc1_3d, merged_data$norm_count_Pc2_3d, log="xy", xlab="Pc1_3d normalized counts", ylab="Pc2_3d normalized counts", main="3d log distribution of normalized counts")
Warning messages:
1: In xy.coords(x, y, xlabel, ylabel, log) :
  13596 x values <= 0 omitted from logarithmic plot
2: In xy.coords(x, y, xlabel, ylabel, log) :
  17012 y values <= 0 omitted from logarithmic plot
> dev.off()
null device 
          1 
> 
> pdf("plots/Pc1_5d__Pc2_5d.pdf")
> plot(merged_data$norm_count_Pc1_5d, merged_data$norm_count_Pc2_5d, log="xy", xlab="Pc1_5d normalized counts", ylab="Pc2_5d normalized counts", main="5d log distribution of normalized counts")
Warning messages:
1: In xy.coords(x, y, xlabel, ylabel, log) :
  14606 x values <= 0 omitted from logarithmic plot
2: In xy.coords(x, y, xlabel, ylabel, log) :
  20239 y values <= 0 omitted from logarithmic plot
> dev.off()
null device 
          1 
> 
> #pdf("plots/Pc1_7d__Pc2_7d.pdf")
> #plot(merged_data$norm_count_Pc1_7d, merged_data$norm_count_Pc2_7d, log="xy", xlab="Pc1_7d normalized counts", ylab="Pc2_7d normalized counts", main="7d log distribution of normalized counts")
> #dev.off()
> 
> pdf("plots/Pc1_9d__Pc2_9d.pdf")
> plot(merged_data$norm_count_Pc1_9d, merged_data$norm_count_Pc2_9d, log="xy", xlab="Pc1_9d normalized counts", ylab="Pc2_9d normalized counts", main="9d log distribution of normalized counts")
Warning messages:
1: In xy.coords(x, y, xlabel, ylabel, log) :
  15515 x values <= 0 omitted from logarithmic plot
2: In xy.coords(x, y, xlabel, ylabel, log) :
  17053 y values <= 0 omitted from logarithmic plot
> dev.off()
null device 
          1 
> 
> png("plots/rep_plots.png", width=1250, height=250)
> par(mfrow=c(1,5))
> plot(merged_data$norm_count_Pc1_0d, merged_data$norm_count_Pc2_0d, log="xy", asp=1, xlab="Pc1_0d normalized counts", ylab="Pc2_0d normalized counts", main="0d log distribution of normalized counts")
Warning messages:
1: In xy.coords(x, y, xlabel, ylabel, log) :
  24887 x values <= 0 omitted from logarithmic plot
2: In xy.coords(x, y, xlabel, ylabel, log) :
  30514 y values <= 0 omitted from logarithmic plot
> plot(merged_data$norm_count_Pc1_1d, merged_data$norm_count_Pc2_1d, log="xy", asp=1, xlab="Pc1_1d normalized counts", ylab="Pc2_1d normalized counts", main="1d log distribution of normalized counts")
Warning messages:
1: In xy.coords(x, y, xlabel, ylabel, log) :
  29473 x values <= 0 omitted from logarithmic plot
2: In xy.coords(x, y, xlabel, ylabel, log) :
  31463 y values <= 0 omitted from logarithmic plot
> plot(merged_data$norm_count_Pc1_3d, merged_data$norm_count_Pc2_3d, log="xy", asp=1, xlab="Pc1_3d normalized counts", ylab="Pc2_3d normalized counts", main="3d log distribution of normalized counts")
Warning messages:
1: In xy.coords(x, y, xlabel, ylabel, log) :
  13596 x values <= 0 omitted from logarithmic plot
2: In xy.coords(x, y, xlabel, ylabel, log) :
  17012 y values <= 0 omitted from logarithmic plot
> plot(merged_data$norm_count_Pc1_5d, merged_data$norm_count_Pc2_5d, log="xy", asp=1, xlab="Pc1_5d normalized counts", ylab="Pc2_5d normalized counts", main="5d log distribution of normalized counts")
Warning messages:
1: In xy.coords(x, y, xlabel, ylabel, log) :
  14606 x values <= 0 omitted from logarithmic plot
2: In xy.coords(x, y, xlabel, ylabel, log) :
  20239 y values <= 0 omitted from logarithmic plot
> plot(merged_data$norm_count_Pc1_9d, merged_data$norm_count_Pc2_9d, log="xy", asp=1, xlab="Pc1_9d normalized counts", ylab="Pc2_9d normalized counts", main="9d log distribution of normalized counts")
Warning messages:
1: In xy.coords(x, y, xlabel, ylabel, log) :
  15515 x values <= 0 omitted from logarithmic plot
2: In xy.coords(x, y, xlabel, ylabel, log) :
  17053 y values <= 0 omitted from logarithmic plot
> dev.off()
null device 
          1 
> 

real	0m30.523s
user	0m21.832s
sys	0m8.377s

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> # Load edgeR.
> library(edgeR)
Loading required package: limma
> 
> # TODO write single function to do the exactTest and pass on arguments for each
> # experimental time points interval.
> 
> ## 0d x 1d
> 
> # Subset counts from matrix for 0d-1d test.
> data_0d1d <- merged_data[c("count_Pc1_0d", "count_Pc2_0d", "count_Pc1_1d", "count_Pc2_1d")]
> rownames(data_0d1d) <- merged_data$reference
> 
> # Set time points.
> time_points <- factor(c("0d", "0d", "1d", "1d"))
> tp_0d1d <- data.frame(Sample=colnames(data_0d1d), time_points)
> 
> # Object for running the test.
> dge_0d1d <- DGEList(counts=data_0d1d, group=tp_0d1d$time_points)
> colnames(dge_0d1d) <- tp_0d1d$Sample
> 
> # Filter counts?
> ##filter read with no/low counts
> #keep <- rowSums(cpm(y)) >= 2
> #y <- y[keep,]
> #
> ##update library sizes
> #y$samples$lib.size <- colSums(y$counts)
> #dim(y)
> 
> # Calculate normalization factor.
> dge_0d1d <- calcNormFactors(dge_0d1d)
> 
> # Estimate dispersion.
> dge_0d1d <- estimateCommonDisp(dge_0d1d, verbose=TRUE)
Disp = 0.43092 , BCV = 0.6564 
> dge_0d1d <- estimateTagwiseDisp(dge_0d1d)
> 
> # Test for differential gene expression.
> test_0d1d <- exactTest(dge_0d1d, pair=c("0d", "1d"))
> 
> # Build table of results.
> table_0d1d <- test_0d1d$table
> table_0d1d <- cbind(rownames(table_0d1d), table_0d1d)
> names(table_0d1d)[names(table_0d1d) == "rownames(table_0d1d)"] = "transcript"
> 
> # Adjust p-values with bonferroni.
> table_0d1d <- cbind(table_0d1d, p.adjust(table_0d1d$PValue, method="bonferroni"))
> names(table_0d1d)[names(table_0d1d)=="p.adjust(table_0d1d$PValue, method = \"bonferroni\")"] = "PAdjust_0d_1d"
> names(table_0d1d)[names(table_0d1d)=="logFC"] = "logFC_0d_1d"
> names(table_0d1d)[names(table_0d1d)=="logCPM"] = "logCPM_0d_1d"
> names(table_0d1d)[names(table_0d1d)=="PValue"] = "PValue_0d_1d"
> 
> ## 1d x 3d
> 
> # Subset counts from matrix for 1d-3d test.
> data_1d3d <- merged_data[c("count_Pc1_1d", "count_Pc2_1d", "count_Pc1_3d", "count_Pc2_3d")]
> rownames(data_1d3d) <- merged_data$reference
> 
> # Set time points.
> time_points <- factor(c("1d", "1d", "3d", "3d"))
> tp_1d3d <- data.frame(Sample=colnames(data_1d3d), time_points)
> 
> # Object for running the test.
> dge_1d3d <- DGEList(counts=data_1d3d, group=tp_1d3d$time_points)
> colnames(dge_1d3d) <- tp_1d3d$Sample
> 
> # Filter counts?
> ##filter read with no/low counts
> #keep <- rowSums(cpm(y)) >= 2
> #y <- y[keep,]
> #
> ##update library sizes
> #y$samples$lib.size <- colSums(y$counts)
> #dim(y)
> 
> # Calculate normalization factor.
> dge_1d3d <- calcNormFactors(dge_1d3d)
> 
> # Estimate dispersion.
> dge_1d3d <- estimateCommonDisp(dge_1d3d, verbose=TRUE)
Disp = 0.32958 , BCV = 0.5741 
> dge_1d3d <- estimateTagwiseDisp(dge_1d3d)
> 
> # Test for differential gene expression.
> test_1d3d <- exactTest(dge_1d3d, pair=c("1d", "3d"))
> 
> # Build table of results.
> table_1d3d <- test_1d3d$table
> table_1d3d <- cbind(rownames(table_1d3d), table_1d3d)
> names(table_1d3d)[names(table_1d3d) == "rownames(table_1d3d)"] = "transcript"
> 
> # Adjust p-values with bonferroni.
> table_1d3d <- cbind(table_1d3d, p.adjust(table_1d3d$PValue, method="bonferroni"))
> names(table_1d3d)[names(table_1d3d)=="p.adjust(table_1d3d$PValue, method = \"bonferroni\")"] = "PAdjust_1d_3d"
> names(table_1d3d)[names(table_1d3d)=="logFC"] = "logFC_1d_3d"
> names(table_1d3d)[names(table_1d3d)=="logCPM"] = "logCPM_1d_3d"
> names(table_1d3d)[names(table_1d3d)=="PValue"] = "PValue_1d_3d"
> 
> ## 3d x 5d
> 
> # Subset counts from matrix for 3d-5d test.
> data_3d5d <- merged_data[c("count_Pc1_3d", "count_Pc2_3d", "count_Pc1_5d", "count_Pc2_5d")]
> rownames(data_3d5d) <- merged_data$reference
> 
> # Set time points.
> time_points <- factor(c("3d", "3d", "5d", "5d"))
> tp_3d5d <- data.frame(Sample=colnames(data_3d5d), time_points)
> 
> # Object for running the test.
> dge_3d5d <- DGEList(counts=data_3d5d, group=tp_3d5d$time_points)
> colnames(dge_3d5d) <- tp_3d5d$Sample
> 
> # Filter counts?
> ##filter read with no/low counts
> #keep <- rowSums(cpm(y)) >= 2
> #y <- y[keep,]
> #
> ##update library sizes
> #y$samples$lib.size <- colSums(y$counts)
> #dim(y)
> 
> # Calculate normalization factor.
> dge_3d5d <- calcNormFactors(dge_3d5d)
> 
> # Estimate dispersion.
> dge_3d5d <- estimateCommonDisp(dge_3d5d, verbose=TRUE)
Disp = 0.26231 , BCV = 0.5122 
> dge_3d5d <- estimateTagwiseDisp(dge_3d5d)
> 
> # Test for differential gene expression.
> test_3d5d <- exactTest(dge_3d5d, pair=c("3d", "5d"))
> 
> # Build table of results.
> table_3d5d <- test_3d5d$table
> table_3d5d <- cbind(rownames(table_3d5d), table_3d5d)
> names(table_3d5d)[names(table_3d5d) == "rownames(table_3d5d)"] = "transcript"
> 
> # Adjust p-values with bonferroni.
> table_3d5d <- cbind(table_3d5d, p.adjust(table_3d5d$PValue, method="bonferroni"))
> names(table_3d5d)[names(table_3d5d)=="p.adjust(table_3d5d$PValue, method = \"bonferroni\")"] = "PAdjust_3d_5d"
> names(table_3d5d)[names(table_3d5d)=="logFC"] = "logFC_3d_5d"
> names(table_3d5d)[names(table_3d5d)=="logCPM"] = "logCPM_3d_5d"
> names(table_3d5d)[names(table_3d5d)=="PValue"] = "PValue_3d_5d"
> 
> ## 5d x 7d
> 
> # Subset counts from matrix for 5d-7d test.
> data_5d7d <- merged_data[c("count_Pc1_5d", "count_Pc2_5d", "count_Pc2_7d")]
> rownames(data_5d7d) <- merged_data$reference
> 
> # Set time points.
> time_points <- factor(c("5d", "5d", "7d"))
> tp_5d7d <- data.frame(Sample=colnames(data_5d7d), time_points)
> 
> # Object for running the test.
> dge_5d7d <- DGEList(counts=data_5d7d, group=tp_5d7d$time_points)
> colnames(dge_5d7d) <- tp_5d7d$Sample
> 
> # Filter counts?
> ##filter read with no/low counts
> #keep <- rowSums(cpm(y)) >= 2
> #y <- y[keep,]
> #
> ##update library sizes
> #y$samples$lib.size <- colSums(y$counts)
> #dim(y)
> 
> # Calculate normalization factor.
> dge_5d7d <- calcNormFactors(dge_5d7d)
> 
> # Estimate dispersion.
> dge_5d7d <- estimateCommonDisp(dge_5d7d, verbose=TRUE)
Disp = 0.21773 , BCV = 0.4666 
> dge_5d7d <- estimateTagwiseDisp(dge_5d7d)
> 
> # Test for differential gene expression.
> test_5d7d <- exactTest(dge_5d7d, pair=c("5d", "7d"))
> 
> # Build table of results.
> table_5d7d <- test_5d7d$table
> table_5d7d <- cbind(rownames(table_5d7d), table_5d7d)
> names(table_5d7d)[names(table_5d7d) == "rownames(table_5d7d)"] = "transcript"
> 
> # Adjust p-values with bonferroni.
> table_5d7d <- cbind(table_5d7d, p.adjust(table_5d7d$PValue, method="bonferroni"))
> names(table_5d7d)[names(table_5d7d)=="p.adjust(table_5d7d$PValue, method = \"bonferroni\")"] = "PAdjust_5d_7d"
> names(table_5d7d)[names(table_5d7d)=="logFC"] = "logFC_5d_7d"
> names(table_5d7d)[names(table_5d7d)=="logCPM"] = "logCPM_5d_7d"
> names(table_5d7d)[names(table_5d7d)=="PValue"] = "PValue_5d_7d"
> 
> ## 7d x 9d
> 
> # Subset counts from matrix for 7d-9d test.
> data_7d9d <- merged_data[c("count_Pc2_7d", "count_Pc1_9d", "count_Pc2_9d")]
> rownames(data_7d9d) <- merged_data$reference
> 
> # Set time points.
> time_points <- factor(c("7d", "9d", "9d"))
> tp_7d9d <- data.frame(Sample=colnames(data_7d9d), time_points)
> 
> # Object for running the test.
> dge_7d9d <- DGEList(counts=data_7d9d, group=tp_7d9d$time_points)
> colnames(dge_7d9d) <- tp_7d9d$Sample
> 
> # Filter counts?
> ##filter read with no/low counts
> #keep <- rowSums(cpm(y)) >= 2
> #y <- y[keep,]
> #
> ##update library sizes
> #y$samples$lib.size <- colSums(y$counts)
> #dim(y)
> 
> # Calculate normalization factor.
> dge_7d9d <- calcNormFactors(dge_7d9d)
> 
> # Estimate dispersion.
> dge_7d9d <- estimateCommonDisp(dge_7d9d, verbose=TRUE)
Disp = 0.15213 , BCV = 0.39 
> dge_7d9d <- estimateTagwiseDisp(dge_7d9d)
> 
> # Test for differential gene expression.
> test_7d9d <- exactTest(dge_7d9d, pair=c("7d", "9d"))
> 
> # Build table of results.
> table_7d9d <- test_7d9d$table
> table_7d9d <- cbind(rownames(table_7d9d), table_7d9d)
> names(table_7d9d)[names(table_7d9d) == "rownames(table_7d9d)"] = "transcript"
> 
> # Adjust p-values with bonferroni.
> table_7d9d <- cbind(table_7d9d, p.adjust(table_7d9d$PValue, method="bonferroni"))
> names(table_7d9d)[names(table_7d9d)=="p.adjust(table_7d9d$PValue, method = \"bonferroni\")"] = "PAdjust_7d_9d"
> names(table_7d9d)[names(table_7d9d)=="logFC"] = "logFC_7d_9d"
> names(table_7d9d)[names(table_7d9d)=="logCPM"] = "logCPM_7d_9d"
> names(table_7d9d)[names(table_7d9d)=="PValue"] = "PValue_7d_9d"
> 
> # Merge results from DGE.
> merged_dge <- merge(table_0d1d, table_1d3d, by.x="transcript", by.y="transcript", all=TRUE)
> merged_dge <- merge(merged_dge, table_3d5d, by.x="transcript", by.y="transcript", all=TRUE)
> merged_dge <- merge(merged_dge, table_5d7d, by.x="transcript", by.y="transcript", all=TRUE)
> merged_dge <- merge(merged_dge, table_7d9d, by.x="transcript", by.y="transcript", all=TRUE)
> 
> # Exclude previous edgeR values (if it is a re-run).
> merged_data$PValue_0d_1d <- NULL
> merged_data$PAdjust_0d_1d <- NULL
> merged_data$logFC_0d_1d <- NULL
> merged_data$logCPM_0d_1d <- NULL
> merged_data$PValue_1d_3d <- NULL
> merged_data$PAdjust_1d_3d <- NULL
> merged_data$logFC_1d_3d <- NULL
> merged_data$logCPM_1d_3d <- NULL
> merged_data$PValue_3d_5d <- NULL
> merged_data$PAdjust_3d_5d <- NULL
> merged_data$logFC_3d_5d <- NULL
> merged_data$logCPM_3d_5d <- NULL
> merged_data$PValue_5d_7d <- NULL
> merged_data$PAdjust_5d_7d <- NULL
> merged_data$logFC_5d_7d <- NULL
> merged_data$logCPM_5d_7d <- NULL
> merged_data$PValue_7d_9d <- NULL
> merged_data$PAdjust_7d_9d <- NULL
> merged_data$logFC_7d_9d <- NULL
> merged_data$logCPM_7d_9d <- NULL
> 
> # Merge differential expression into matrix.
> merged_data <- merge(merged_data, merged_dge, by.x="reference", by.y="transcript", all=TRUE)
Warning message:
In merge.data.frame(merged_data, merged_dge, by.x = "reference",  :
  column names ‘norm_count_Pc1_0d’, ‘norm_count_Pc2_0d’, ‘norm_count_Pc1_1d’, ‘norm_count_Pc2_1d’, ‘norm_count_Pc1_3d’, ‘norm_count_Pc2_3d’, ‘norm_count_Pc1_5d’, ‘norm_count_Pc2_5d’, ‘norm_count_Pc2_7d’, ‘norm_count_Pc1_9d’, ‘norm_count_Pc2_9d’ are duplicated in the result
> # TODO Is there a need to sort?
> 

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> # Load function to count.
> source("count_deg_intervals.r")
> 
> # Counts for all data.
> deg_counts_all <- count_deg(merged_data)
> 

real	2m11.488s
user	1m15.307s
sys	0m56.050s

R version 3.1.1 (2014-07-10) -- "Sock it to Me"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-redhat-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> # Load plot function.
> source("de_plot.r")
> 
> # Plot all data set highlighting differentially expressed genes.
> de_plots(merged_data, deg_counts_all, "plots/de_genes.png")
null device 
          1 
> 

real	0m25.688s
user	0m25.235s
sys	0m0.382s
